We will solve 75 LeetCode practice. The following table shows name of problems with description.

| Number |Problem title| Description|Example|
|--------|-------------|------------|-------|
| 1. |Two Sum| Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.| Input: nums = [2,7,11,15], target = 9, Output: [0,1],Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].|
|2.| Add Two Numbers| You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.| Input: l1 = [2,4,3], l2 = [5,6,4], Output: [7,0,8], Explanation: 342 + 465 = 807.|
|3.|Longest Substring Without Repeating Characters| Given a string s, find the length of the longest 
substring without repeating characters.| Input: s = "abcabcbb", Output: 3, Explanation: The answer is "abc", with the length of 3.| 
|4. | Median of Two Sorted Arrays| Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).| Input: nums1 = [1,3], nums2 = [2], Output: 2.00000, Explanation: merged array = [1,2,3] and median is 2.|
|5. | Longest Palindromic Substring| Given a string s, return the longest palindromic(A string is palindromic if it reads the same forward and backward.) substring in s.| Input: s = "babad", Output: "bab", Explanation: "aba" is also a valid answer.|
|6. | Zigzag Conversion | The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) | Input: s = "PAYPALISHIRING", numRows = 3, Output: "PAHNAPLSIIGYIR" |
|7. | Reverse Integer | Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.| Input: x = 123, Output: 321|
|8. | Merge Strings Alternately |You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string. Return the merged string.|Input: word1 = "abc", word2 = "pqr" Output: "apbqcr" |
|9. | Greatest Common Divisor of Strings |For two strings s and t, we say "t divides s" if and only if s = t + t + t + ... + t + t (i.e., t is concatenated with itself one or more times). Given two strings str1 and str2, return the largest string x such that x divides both str1 and str2.| Input: str1 = "ABCABC", str2 = "ABC" Output: "ABC"|
|10. | Reverse Vowels of a String |Given a string s, reverse only all the vowels in the string and return it. The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.| Input: s = "leetcode" Output: "leotcede"|
|11. |Reverse Words in a String |Given an input string s, reverse the order of the words. A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space. Return a string of the words in reverse order concatenated by a single space. Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces. | Input: s = "  hello world  " Output: "world hello"|
|12. |Product of Array Except Self |Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation.| |
|13. |Increasing Triplet Subsequence |Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false.| Input: nums = [1,2,3,4,5] Output: true, Input: nums = [5,4,3,2,1] Output: false|
|14. | Move Zeroes |Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array.|Input: nums = [0,1,0,3,12] Output: [1,3,12,0,0] |
|15. | Is Subsequence|Given two strings s and t, return true if s is a subsequence of t, or false otherwise. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., "ace" is a subsequence of "abcde" while "aec" is not).|Input: s = "abc", t = "ahbgdc" Output: true |
|16. | Max Number of K-Sum Pairs |You are given an integer array nums and an integer k. In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array. Return the maximum number of operations you can perform on the array. |Input: nums = [1,2,3,4], k = 5 Output: 2 |
|17. |Maximum Average Subarray I |You are given an integer array nums consisting of n elements, and an integer k. Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted.| Input: nums = [1,12,-5,-6,50,3], k = 4 Output: 12.75000|
|18. |Maximum Number of Vowels in a Substring of Given Length | Given a string s and an integer k, return the maximum number of vowel letters in any substring of s with length k. Vowel letters in English are 'a', 'e', 'i', 'o', and 'u'.| Input: s = "abciiidef", k = 3 Output: 3|
|19. |Search Insert Position |Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity| nums = [1, 3, 5, 6] target = 5 Output: 2 |
|20. |Same Tree |Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.| Input: p = [1,2,3], q = [1,2,3] Output: true|
|21. | Single Number |Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space.| Input: nums = [2,2,1] Output: 1|
|22. | Subsets |Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.|Input: nums = [1,2,3] Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] |
|23. |Rotate Image|You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.|Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [[7,4,1],[8,5,2],[9,6,3]] |
|24. |Maximum Binary Tree |You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm: Create a root node whose value is the maximum value in nums. Recursively build the left subtree on the subarray prefix to the left of the maximum value. Recursively build the right subtree on the subarray suffix to the right of the maximum value. Return the maximum binary tree built from nums.| |
|25. |Max Consecutive Ones III|Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.|Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2 Output: 6 Explanation: [1,1,1,0,0,1,1,1,1,1,1] Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. |
|26. |Longest Subarray of 1's After Deleting One Element |Given a binary array nums, you should delete one element from it.Return the size of the longest non-empty subarray containing only 1's in the resulting array. Return 0 if there is no such subarray. | Input: nums = [1,1,0,1] Output: 3 Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's. |
|27. |Find the Highest Altitude |There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0. You are given an integer array gain of length n where gain[i] is the net gain in altitude between points i​​​​​​ and i + 1 for all (0 <= i < n). Return the highest altitude of a point.|Input: gain = [-5,1,5,0,-7] Output: 1 Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.|
|28. |Find Pivot Index |Given an array of integers nums, calculate the pivot index of this array. The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right. If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array. Return the leftmost pivot index. If no such index exists, return -1.| Input: nums = [1,7,3,6,5,6] Output: 3|
|29. | Find the Difference of Two Arrays |Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where: answer[0] is a list of all distinct integers in nums1 which are not present in nums2. answer[1] is a list of all distinct integers in nums2 which are not present in nums1. Note that the integers in the lists may be returned in any order.| Input: nums1 = [1,2,3], nums2 = [2,4,6] Output: [[1,3],[4,6]]|
|30. |Unique Number of Occurrences |Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise. | Input: arr = [1,2,2,1,1,3] Output: true|
|31. |Determine if Two Strings Are Close | Two strings are considered close if you can attain one from the other using the following operations: Operation 1: Swap any two existing characters. For example, abcde -> aecdb Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character. For example, aacabb -> bbcbaa (all a's turn into b's, and all b's turn into a's) You can use the operations on either string as many times as necessary. Given two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise.| Input: word1 = "abc", word2 = "bca" Output: true|
|32. | Equal Row and Column Pairs |Given a 0-indexed n x n integer matrix grid, return the number of pairs (ri, cj) such that row ri and column cj are equal. A row and column pair is considered equal if they contain the same elements in the same order (i.e., an equal array).| Input: grid = [[3,2,1],[1,7,6],[2,7,7]] Output: 1 Explanation: There is 1 equal row and column pair: - (Row 2, Column 1): [2,7,7]|
|33. | Removing Stars From a String |You are given a string s, which contains stars *. In one operation, you can: Choose a star in s. Remove the closest non-star character to its left, as well as remove the star itself. Return the string after all stars have been removed. Note: The input will be generated such that the operation is always possible. It can be shown that the resulting string will always be unique.| Input: s = "leet**cod*e" Output: "lecoe"|
|34. | Asteroid Collision | We are given an array asteroids of integers representing asteroids in a row. For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed. Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.| Input: asteroids = [5,10,-5] Output: [5,10] Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.|
|35. | Decode String | Given an encoded string, return its decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4]. The test cases are generated so that the length of the output will never exceed 105. | Input: s = "3[a]2[bc]" Output: "aaabcbc"|
|36. |Kth Largest Element in an Array | Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Can you solve it without sorting?| Input: nums = [3,2,1,5,6,4], k = 2 Output: 5|
|37. | Maximum Subsequence Score |You are given two 0-indexed integer arrays nums1 and nums2 of equal length n and a positive integer k. You must choose a subsequence of indices from nums1 of length k. For chosen indices i0, i1, ..., ik - 1, your score is defined as: The sum of the selected elements from nums1 multiplied with the minimum of the selected elements from nums2. It can defined simply as: (nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1]). Return the maximum possible score. A subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.| Input: nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3 Output: 12|
|38. |Successful Pairs of Spells and Potions | You are given two positive integer arrays spells and potions, of length n and m respectively, where spells[i] represents the strength of the ith spell and potions[j] represents the strength of the jth potion.You are also given an integer success. A spell and potion pair is considered successful if the product of their strengths is at least success. Return an integer array pairs of length n where pairs[i] is the number of potions that will form a successful pair with the ith spell. |Input: spells = [5,1,3], potions = [1,2,3,4,5], success = 7 Output: [4,0,3]|
|39. | Find Peak Element | A peak element is an element that is strictly greater than its neighbors. Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array. You must write an algorithm that runs in O(log n) time. | Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2.|
|40. | Combination Sum III |Find all valid combinations of k numbers that sum up to n such that the following conditions are true: Only numbers 1 through 9 are used. Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.|Input: k = 3, n = 7 Output: [[1,2,4]]|
|41. |N-th Tribonacci Number | The Tribonacci sequence Tn is defined as follows: T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0. Given n, return the value of Tn.|Input: n = 4 Output: 4 |
|42. | Min Cost Climbing Stairs |You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps. You can either start from the step with index 0, or the step with index 1. Return the minimum cost to reach the top of the floor.| Input: cost = [10,15,20] Output: 15 |
|43. | Largest Number At Least Twice of Others | You are given an integer array nums where the largest integer is unique.Determine whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, or return -1 otherwise. | Input: nums = [3,6,1,0] Output: 1 Explanation: 6 is the largest integer. For every other number in the array x, 6 is at least twice as big as x. The index of value 6 is 1, so we return 1.|
|44. | Unique Paths | There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 109.| Input: m = 3, n = 7 Output: 28 |
|45. | Edit Distance | Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You have the following three operations permitted on a word: Insert a character Delete a character Replace a character| Input: word1 = "horse", word2 = "ros" Output: 3 Explanation:  horse -> rorse (replace 'h' with 'r') rorse -> rose (remove 'r') rose -> ros (remove 'e') |
|46. | Counting Bits | Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.| Input: n = 2 Output: [0,1,1] Explanation: 0 --> 0 1 --> 1 2 --> 10|
|47. | Maximum Subarray || |
|48. | Merge Intervals || |
|49. | Longest Increasing Subsequence || |
|50. | Container With Most Water || |
|51. | Valid Parentheses || |
|52. | Find Minimum in Rotated Sorted Array || |
|53. | Top K Frequent Elements || |
|54. | Search in Rotated Sorted Array || |
